\documentclass[notes.tex]{subfiles}

\begin{document}

O que este trabalho propõe é um modelo algorítmico de geração de redes complexas que produza grafos mais realistas.
Realista nesse contexto é entendido como tendo a presença de um conjunto de propriedades que se observam em grafos do mundo real.
A proposta desse trabalho é a extensão do modelo de \citeonline{largeron2015generating} para a construção de grafos em que se apresentem também as propriedades de comunidades hierárquicas e comunidades sobrepostas.
A modelagem proposta se baseia na construção de uma cobertura (em oposição á construção de uma partição) recursiva, de forma semelhante ao que é produzido pelo algoritmo de detecção proposto por \citeonline{shen2009detect}.


\section{Hipótese}

\subsection{A Representação do grafo}

O model gera um grafo com atributos e uma cobertura de comunidades hierarquicamente dispostas.

\begin{quadro}[htb]
    \caption{Modelagem de grafo com comunidades hierárquicas e sobrepostas}
    \label{qua:representacao}

    \begin{empheq}[box=\fbox]{align*}
        \G &= (\V, \E, C_n) \\
        \V &\subset  \mathbb{Q}^{p} \\
        \E &\subset \set{v_1, v_2 | v_1 \in \V, v_2 \in \V} \\
         C_0 &\subset \Set{v | v \in \V} \\
         C_n &= \Set{C_{n-1_0}, C_{n-1_1}, \ldots, C_{n-1_m}}
    \end{empheq}

    \fonte{elaborado pelo autor}
\end{quadro}

Os vértices em $\V$ são uma nuvem de pontos em um espaço de $p$ dimensões, cada um sendo um vetor com $p$ valores racionais (representados com ponto flutuante).
As arestas em $\E$ são simples pares não ordenados de vértices.
A cobertura $C_n$ é uma estrutura recursiva de conjuntos com $n$ níveis, onde o conjunto $C_n$ é composto por $m$ conjuntos $C_{n-1}$.
No último níveo o conjunto $C_0$ é composto por vértices do grafo, esses conjuntos são as comunidades \emph{folha}, significando que elas não são compostas por outras comunidades.

Essa estrutura recursiva é a representação das comunidades hierárquicas, onde os vértices que pertencem a uma comunidade $C$, denotado $V_C$ são os membros do conjunto união dos membros de  $C$, isso é, $\bigcup_{S \in c} V_S$.
Como característica dessa modelagem, os vértices da comunidade representada por $C_n$ são a totalidade dos vértices do grafo, portanto $V_{C_n} = \V$
Isso implica que para qualquer vértice em $\V$, ele deve de estar presente pelo menos uma comunidade folha.
Ao estar presente em uma comunidade folha, o vértice é considerando também parte de todas as comunidades compostas por esta comunidade folha.

A cardinalidade de cada um dos conjuntos que formam a cobertura é variável de acordo com o nível, isso é, dado um nível $x$ todas as coberturas  $C_{n-x}$ possuem a mesma quantidade de elementos, mas conjuntos de níveis distintos podem possuir quantidades de elementos distintas.
É considerada também a existência de um vetor, denotado $K$, em um espaço de $n-1$ dimensões, que denota a cardinalidade das coberturas compostas por outras coberturas.
Todas as comunidades do grafo $\G$ contém pelo menos um membro.

Uma característica de notação é a função flat que mapeia uma comunidade para um conjunto de quais as comunidades que a compõe.
Para efeito de notação $\text{flat}(C_n)$ é um conjunto com todas as comunidades do grafo, incluindo a comunidade global.
E o mapa $L$, que relaciona cada comunidade com a quantidade de ancestrais que a comunidade possui, ou seja, com a quantidade de comunidades que ela compõe.
As notações utilizadas serão  $L_C$, leia-se nível de $C$, ou $L$, leia-se níveis.
A raiz da cobertura é o nível zero ($L_{C_n} = 0$) e a o nível de um nó folha é igual a $n$ ($L_{C_0}=n$)
As características que devem ser verdadeiras se um grafo for representado nesta modelagem encontram-se descritas na \autoref{tab:prop_representacao}.

\begin{table}[htb]
    \centering
    \caption{Características da modelagem}
    \label{tab:prop_representacao}

    \begin{tblr}{X|l} \hline
        \SetCell{c} Característica & \SetCell{c} Formalismo
        \\ \hline
        Para toda a comunidade $C$, se ela não for folha, a função flat dela é a união de $C$ com a função flat de seus componentes.&
        $\displaystyle \forall C (L_C < n \implies \text{flat}(C) = C\cup\bigcup_{S \in C}\text{flat}(S))$
        \\\hline
        Para toda a comunidade $C$, se ela for folha, a função flat dela é um conjunto consigo.&
        $\displaystyle \forall C (L_C = n \implies \text{flat}(C) = \set{C})$
        \\\hline
        A comunidade raiz engloba todos os vértices do grafo.&
        $\displaystyle V_{C_n} =  \V$
        \\ \hline
        Para todas as comunidades $C$, se $C$ não for folha, os vértices englobados em C são a união dos vértices englobados em seus componentes&
        $\displaystyle \forall C (L_C > 0 \implies V_C =  \bigcup_{S \in C} V_S)$
        \\ \hline
        Para todas as comunidades $C$, se $C$ for folha, os vértices englobados em C seus componentes&
        $\displaystyle \forall C (L_C = 0 \implies V_{C_0} = C_0)$
        \\ \hline
        Para todos os vetores do grafo, existe uma comunidade folha a qual ela pertence &
        $\displaystyle \forall v (\exists C(v \in C \land L_C = n))$
        \\ \hline
        Pra todo vértice $v$, pra todo $l$, existe uma comunidade $C$ que contenha o vértice e seja do nível $l$&
        $\displaystyle \forall v \forall l (\exists C (v \in V_{C_x} \land L_C = l))$
        \\ \hline
        Todos as comunidades não folha tem a mesma quantidade de componentes se forem do mesmo nível, a cardinalidade de uma comunidade não folha é expressa num vetor $K$ &
        $\displaystyle \exists K (K \in \mathbb{I}^{n-1} \land \forall C (L_C < n \implies K_{L_C} = |C|))$
        \\ \hline
        Toda a comunidade tem pelo menos uma componente e engloba pelo menos um vértice&
        $\displaystyle \forall C (|C| \ge 1 \land |V_C| \ge 1)$
        \\ \hline
    \end{tblr}

    \fonte{elaborado pelo autor}
\end{table}

\subsection{Propriedades desejáveis do modelo}

\citeonline{largeron2015generating} implementa um modelo algorítmico de geração de redes complexas que mantém uma série de propriedades desejáveis.
Como a implementação proposta se baseia no modelo de \citeonline{largeron2015generating}, é desejável que as propriedades sejam mantidas.
Nominalmente, são elas:

\begin{alineas}
    \item Mundo pequeno: O diâmetro das redes complexas geradas pelo modelo deve ter uma relação logarítmica com a quantidade de vértices no modelo.
    \item Distribuição de graus em lei de potência: Os graus dos vértices devem estar distribuídos com uma lei de potência.
    \item Homofilia: O grafo gerado deve apresentar uma tendência de priorização da adjacência com vértices semelhantes.
    \item Estrutura de comunidades: O grafo gerado deve de ter comunidades, conforme etiquetadas na cobertura, de forma que todo vértice pertença a uma ou mais comunidades, e as comunidades se organizem em uma estrutura hierárquica.
    \item Comunidades homogêneas: As comunidades devem ser coesas não apenas na perspectiva topológica, mas em similaridade.
\end{alineas}

Para tanto, a abordagem do modelo é a construção explicita das comunidades com base na similaridade dos vértices.
Para isso, a similaridade dos vértices é definida com base na distância euclideana dos vetores de atributos dos vértices.
As arestas do grafo são definidas com base nas comunidades das quais o vértice faz parte.

Essa implementação visa garantir a homogeneidade das comunidades e a homofilia ao selecionar os membros das comunidades estocasticamente preferindo vértices com menor distância euclideana.
A construção das arestas é feita priorizando a introdução de vértices a vértices com mais arestas dentro da comunidade, de forma a reforçar a distribuição de graus em lei de potência e a estrutura de comunidade, bem como a propriedade de mundo pequeno.

\section{Algoritmo}

\subsection{Parâmetros}

As propriedades descritas podem ser controladas utilizando uma série de parâmetros.
Os parâmetros seguem descritos na tabela \autoref{tab:parameters}.
Eles são uma adaptação bastante direta dos parâmetros do modelo de \citeonline{largeron2015generating}, a difere-a mais significativa é no parâmetro $K$, que é um vetor multi dimensional de inteiros maiores que 1.
Isso se deve à construção de uma árvore de comunidades hierarquicamente aninhadas.

\begin{table}[htb]
    \centering
    \caption{Características da modelagem}
    \label{tab:parameters}

    \begin{tblr}{l|X} \hline
        \SetCell{c} Parâmetro & \SetCell{c} Descrição
        \\ \hline
        $N \in \set{n \in \mathbb{N} | n \ge 1}$&
        Quantidade de vértices.
        \\ \hline
        $E_\text{wth}^\text{max} \in \set{i \in \mathbb{N} | i \ge 1}$&
        Número máximo de arestas (internas a comunidade) inseridas a um vértice ao introduzir ele a uma comunidade.
        \\ \hline
        $E_\text{btw}^\text{max} \in \set{i \in \mathbb{N} | i \ge 1}$&
        Número máximo de arestas (externas a comunidade) inseridas a um vértice ao introduzir ele as comunidades.
        \\ \hline
        $MTE \in \set{m \in \mathbb{N} | m \ge 1}$&
        Número mínimo de arestas no grafo produzido.
        \\ \hline

        $\A \in \set{a \in \mathbb{Q} | a > 0}^{|\A|}$ &
        Vetor de desvios padrão dos atributos dos vértices.
        \\ \hline
        $K \in \set{k \in \mathbb{N} | k \ge 2}^{|K|}$&
        Vetor de quantidade de comunidades por nível
        \\ \hline
        $\theta \in \set{t \in \mathbb{Q} | 0 \ge t \ge 1}$&
        Valor de interpolação entre homogeneidade por distância euclideana e distância por ortogonalidade de comunidade.
        \\ \hline
        $\text{NbRep} \in \set{n \in \mathbb{N} | n \ge 1}$&
        Número de representantes por comunidade.
        \\ \hline

    \end{tblr}

    \fonte{elaborado pelo autor}
\end{table}

\subsection{Inicialização}

A primeira faze do algoritmo é a inicialização dos vértices e das comunidades.
Conforme definido no \autoref{qua:faze_1}.

\begin{quadro}[htb]
\caption{Faze 1 do modelo}
\label{qua:faze_1}
\begin{algorithm}[escapeinside={/*}{*/}]
Input: $N$, $\A$, $K$, $\text{NbRep}$
Output: $\G = (\V, \E, C)$

$\V \leftarrow \emptyset$
$\E \leftarrow \emptyset$
while $|\V| < N$ do
begin
    $v \leftarrow (\mathcal{N}(0, \sigma_{\A_0}), \mathcal{N}(0, \sigma_{\A_1}), \ldots, \mathcal{N}(1, \sigma_{\A_{|\A|-1}}))$
    $\V \leftarrow \V \cup \set{v}$
end

Function $\text{cover}$($l$, $p$)
begin
    if $l = |K|$ then
    begin
        for $v \in p$ do
        begin
            $p' \leftarrow \Set{v' \in p | \set{v, v'} \not\in \E \land \set{v, v'} \not\in \E \land v' \neq v}$
            $s \leftarrow \text{Rand}_\text{Uni}([1, |p'|])$
            for $v'\in \text{Sample}(p', s)$ do $\E \leftarrow \E \cup (v, v')$
        end
        return $p$
    end
    $s \leftarrow \text{NbRep}\times\prod_{i=l}^{|K|-1} K_i$
    $p' \leftarrow \text{Sample}(p, \min\set{s, |p|})$
    $k \leftarrow \text{K Medoids}(p', K_l)$ 
    $c \leftarrow \set{\text{cover}(l+1, q) | q \in k}$

    $p' \leftarrow \set{\text{Rand}_\text{Uni}(c') | c' \in V_c}$
    $\E \leftarrow \E \cup \set{\Set{p'_i, p'_{i+1}}| i \in \set{1, 2, \ldots |p'| -1}}$

    return $c$
end

$C = \text{cover}(0, \V)$
for $c \in \Set{c' \in \text{flat}(C) | L_{c'}=|K|}$ do $c$.rep $\leftarrow$ $c$
for $c \in \Set{c' \in \text{flat}(C) | L_{c'}\neq|K|}$ do $c$.rep $\leftarrow$ $\emptyset$

$\G \leftarrow (\V, \E, C)$
Return $\G$
\end{algorithm}
\fonte{elaborado pelo autor}
\end{quadro}

O processo da inicialização se divide em gerar a nuvem de pontos e inicializar as comunidades.
A linha quatro inicializa $\V$ com um conjunto vazio, e o laço de repetição das linhas 6 á 10 insere vetores neste conjunto enquanto ele tiver menos de  $N$ membros.
O vetor em si é definido como uma série de distribuições aleatórias com o centro em zero e o desvio padrão informado pelo parâmetro $\A$.

O processo de geração das estruturas de comunidade é mais complexo, exigindo uma função para possibilitar recursividade.
A função cover tem como condicionante a característica de se a comunidade que se está processando é folha, isso é, se ela não possuirá subdivisões internas.
Na linha 14 é feita essa ramificação, considerando que $l$, um parâmetro de controle que é incrementado a cada chamada recursiva.
Se $l$ for igual á cardinalidade de $k$, isso indica que estamos no último nível a ser gerado.

O processo para o último nível sendo gerado gera um conjunto de arestas entre os membros da comunidade, recebidos por parâmetro com $p$.
Nas linhas 16 até 20 é iterado sobre os vértices, os vértices com quem é possível formar arestas, nomeado $p'$, são definidos como os vértices em $p$ diferentes de $v$ com quem $v$ não é ajacente.
Nas linhas 19 e 20 uma quantidade aleatória das arestas possíveis são construídas.

As funções $\text{Rand}_{\text{Uni}}$ e $\text{Sample}$ são duas funções de escolha aleatória uniformes.
$\text{Sample}(P, l)$ escolhe um sub conjunto de $P$ com $l$ elementos uniformemente distribuído, i.e., todos os membros de $P$ tem a mesma chance de estar presente no conjunto construído.
$\text{Rand}_{\text{Uni}(P)}$ funciona da mesma forma, mas retorna um único membro de $P$.

No caso de não ser uma comunidade folha, o processo de construção da comunidade encontra-se nas linhas 24 até 30.
Para isso primeiramente é definido um tamanho de amostragem $s$.
Esse tamanho é definido como um produto dos valores de $K$, filtrando para o nível atual em diante.
Com isso, buscasse uma amostra $p'$, com tamanho  $s$ ou o valor máximo possível se  $s$ for maior que a quantidade de membros em  $p$.

Com essa amostra, é realizado um agrupamentos utilizando o algoritmo $\text{K Medoids}$.
Nesses clusters iniciais é realizada a chamada recursiva da função $\text{cover}$, que faz a construção da comunidade composta pelos vértices do cluster.
Com as comunidades definidas e agrupadas no conjunto $c$, que representa a comunidade que se está processando, é realizada a introdução de arestas para que a comunidade seja conexa.
Assumindo que todas as comunidades geradas por meio da função  $\text{cover}$ sejam conexas, é construído um caminho que liga um membro de cada comunidade.
A função se conclui retornando a comunidade criada.

A chamada original para a função $\text{cover}(l, p)$ é feita com $l$ sendo zero e  $p$ sendo a nuvem de pontos.
Por fim, o processo também realiza a atribuição dos representantes de cada comunidade folha como sendo a totalidade dos membros da comunidade, e mantendo as demais comunidades sem representantes.

\end{document}
